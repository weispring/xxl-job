## xxjob
优点：解耦、操作简单、灵活、支持客户端和服务端集群部署

### 1.客户端
#### 1.注册job对应的handMethod
通过从spring容器中查找带有注解的方法和bean，进行注册jobName和MethodHandler
#### 2.固定频率的发起http请求(心跳)，向admin注册地址。
#### 3.调用处理过程。
当任务调用从端调用过来时，通过jobId获取对应的线程，若没有则注册相应的线程进入map。然后将请求放入thread对应的队列中，后续获取队列任务去执行，执行完毕http回调通知结果。执行任务过程中，打印日志并保存了日志文件，admin端可以rpc获取。

### admin
#### 1.提供了注册、移除注册、回调的api接口。
#### 2.通过数据库锁避免admin集群部署时，任务重复执行。通过两个线程池异步调用客户端。调用前保存日志，
回调时保存结果。
```
调用（netty和http,client代码暂不清楚）
netty
创建代理通过netty调用

com.xxl.job.core.server.EmbedServer.EmbedHttpServerHandler#process
```

### 设计
#### 1.思想
```
将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。
将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；
```

#### 2.路由策略：执行器集群部署时提供丰富的路由策略。
包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；


#### 3.阻塞处理策略：调度过于密集执行器来不及处理时的处理策略。
单机串行（默认）、丢弃后续调度、覆盖之前调度

#### 4.线程池隔离
调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性；

#### 5.过期处理策略
任务调度错过触发时间时的处理策略：
可能原因：服务重启；调度线程被阻塞，线程被耗尽；上次调度持续阻塞，下次调度被错过；
处理策略：
过期超5s：本次忽略，当前时间开始计算下次触发时间
过期5s内：立即触发一次，当前时间开始计算下次触发时间

#### 6.全异步化 & 轻量级
全异步化设计：XXL-JOB系统中业务逻辑在远程执行器执行，触发流程全异步化设计。相比直接在调度中心内部执行业务逻辑，极大的降低了调度线程占用时间；
异步调度：调度中心每次任务触发时仅发送一次调度请求，该调度请求首先推送“异步调度队列”，然后异步推送给远程执行器
异步执行：执行器会将请求存入“异步执行队列”并且立即响应调度中心，异步运行。
轻量级设计：XXL-JOB调度中心中每个JOB逻辑非常 “轻”，在全异步化的基础上，单个JOB一次运行平均耗时基本在 “10ms” 之内（基本为一次请求的网络开销）；因此，可以保证使用有限的线程支撑大量的JOB并发运行；
得益于上述两点优化，理论上默认配置下的调度中心，单机能够支撑 5000 任务并发运行稳定运行；

实际场景中，由于调度中心与执行器网络ping延迟不同、DB读写耗时不同、任务调度密集程度不同，会导致任务量上限会上下波动。

如若需要支撑更多的任务量，可以通过 “调大调度线程数” 、”降低调度中心与执行器ping延迟” 和 “提升机器配置” 几种方式优化。


#### 7.均衡调度
调度中心在集群部署时会自动进行任务平均分配，触发组件每次获取与线程池数量（调度中心支持自定义调度线程池大小）相关数量的任务，避免大量任务集中在单个调度中心集群节点；

#### 8.多种编程语言
执行job支持多种语言编写。


## 问题
1.通过netty或者http调用时，客户端接受代码为何都是netty,如何解析路由呢？需要学习一下。
2.注册地址的用处？新增时即使选择自动注册此处可以更新地址信息，当然还好进行超时未进行注册处理等。
3.心跳检测？在路由策略故障转移时使用到